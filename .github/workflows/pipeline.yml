name: Pipeline

on:
  push:
#    branches:
#      - '*'
#      - '!master'
  pull_request:
    types:
      - closed
  release:
    types:
      - prereleased
      - released
    tags:
      - 'v*'

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_DEFAULT_REGION: 'us-east-1'
  AWS_STORAGE_BUCKET_NAME: 'nr-clone'
  S3_REPO_URL: 's3://nr-clone'
  TAG: ${{ github.event.release.tag_name }}
  GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
  GITHUB_WORKSPACE: ${{ github.workspace }}
  REPO_NAME: ${{ github.event.repository.name }}
  REPO_FULL_NAME: ${{ github.event.repository.full_name }}
  GPG_APT_PRIVATE_KEY: ${{ secrets.GPG_APT_PRIVATE_KEY_BASE64 }} # base64 encoded
  GPG_APT_PASSPHRASE: ${{ secrets.GPG_APT_PASSPHRASE }}
  GPG_APT_MAIL: 'infrastructure-eng@newrelic.com' # Mail associated to GPG key
  GPG_RPM_PRIVATE_KEY_BASE64: ${{ secrets.GPG_RPM_PRIVATE_KEY_BASE64 }}
  GPG_RPM_PASSPHRASE: ${{ secrets.GPG_RPM_PASSPHRASE }}
  PFX_CERTIFICATE_BASE64: ${{ secrets.PFX_CERTIFICATE_BASE64 }} # base64 encoded
  PFX_PASSPHRASE: ${{ secrets.PFX_PASSPHRASE }}
  DYNAMO_TABLE_NAME: 's3-repo-lock'
  DEPOT_REPO: 'https://github.com/jportasa/depot'
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
  NRI_DOCKER_VERSION: 1.3.0
  NRI_DOCKER_ARCH: amd64
  NRI_FLEX_VERSION: 1.3.2
  NRI_FLEX_OS: Linux
  NRI_FLEX_ARCH: x86_64

jobs:
#
#
#  Build binaries/packages
#
##

#  harvest-tests-create:
#    name: Harvest tests in Ubuntu:18.04
#    runs-on: ubuntu-18.04
#    steps:
#      - name: Check out code
#        uses: actions/checkout@v1
#        with:
#          fetch-depth: 1
#          path: go/src/github.com/jportasa/infrastructure-agent
#      - name: Create the binary
#        env:
#          PARENT_BUILD_NUMBER: nose
#        run: |
#          pwd; go env; export GOOS=linux; export GOARCH=amd64; export GOPATH=/home/runner/work/infrastructure-agent/go/src; go test github.com/jportasa/infrastructure-agent/tree/master/test/harvest -tags="harvest" -v -c -o harvest_\${PARENT_BUILD_NUMBER}.test
##      - name: Push binary to GH workflow artifacts cache
##        uses: actions/upload-artifact@v2
##        with:
##          name: Windows-bin-artifacts
##          path: target/bin/**/*


#  goreleaser:
#    name: Goreleaser
#    if: github.event.action == 'released'
#    runs-on: ubuntu-latest
#    env:
#      GITHUB_PUSH_RELEASE_ASSETS: false
#    steps:
#      - uses: actions/checkout@v2
#      - name: Unshallowify the repo clone # So GoReleaser can generate the changelog properly
#        run: git fetch --prune --unshallow
#      - name: Check GH event is Release or Prerelease
#        if: github.event_name == 'release'
#        run: echo "::set-env name=GITHUB_PUSH_RELEASE_ASSETS::true"
#      - name: Create binaries/.deb/rpm & Push to GH Release Assets (if Release/Prerelease)
#        env:
#          GITHUB_REF: $GITHUB_REF
#          PROJECTNAME: $REPO_NAME
#          GOPATH: '/go'
#        run: |
#          cd cicd
#          docker-compose --file docker_compose_goreleaser.yml run goreleaser
#
#  tarballs:
#    name: Tarballs for Linux & Win creation
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    env:
#      GITHUB_PUSH_RELEASE_ASSETS: false
#    steps:
#      - uses: actions/checkout@v2
#      - name: Unshallowify the repo clone # So GoReleaser can generate the changelog properly
#        run: git fetch --prune --unshallow
#      - name: Check GH event is Release or Prerelease
#        if: github.event_name == 'release'
#        run: echo "::set-env name=GITHUB_PUSH_RELEASE_ASSETS::true"
#      - name: Create tarballs for Linux & Windows and push to GH Release Assets (if Release/Prerelease)
#        run: |
#          cd cicd
#          docker-compose --file docker_compose_tarball_creator.yml run tarballcreator
#
  msi:
    name: MSI creation
#    if: github.event.action == 'released'
#    needs: [goreleaser]
    runs-on: windows-2019
    steps:
#    - name: Get PFX certificate from GH secrets
#      shell: bash
#      run: |
#        printf "%s" "$PFX_CERTIFICATE_BASE64" | base64 -d - > ./mycert.pfx
#    - name: Import PFX certificate from GH Secrets
#      shell: pwsh
#      run: |
#        $PFX_PASSPHRASE = $env:PFX_PASSPHRASE
#        Import-PfxCertificate -FilePath .\mycert.pfx -Password (ConvertTo-SecureString -String $PFX_PASSPHRASE -AsPlainText -Force) -CertStoreLocation Cert:\LocalMachine\Root
    - name: Download Win binaries from GH release
      shell: pwsh
      run: |
        $arch = 'amd64'
        $file = "newrelic-infra_binaries_windows_1.0.27_$arch.zip"
        $url = "https://github.com/jportasa/infrastructure-agent/releases/download/v1.0.27/$file"
        Invoke-WebRequest $url -OutFile $file
        Expand-Archive $file -DestinationPath ".\target\bin\windows_$arch\"
        ls ".\target\bin\windows_$arch\"
    - name: Create .msi
      shell: pwsh
      run: |
        $arch = 'amd64'
        #$msBuild = (Get-ItemProperty hklm:\software\Microsoft\MSBuild\ToolsVersions\4.0).MSBuildToolsPath
        Push-Location -Path "build\package\windows\newrelic-infra-$arch-installer\newrelic-infra"
        . MSBuild.exe newrelic-infra-installer.wixproj


#  s3-apt-update:
#    name: S3 repo APT update
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    env:
#      BASE_PATH: "infrastructure_agent/linux/apt"
#      LOCK_REPO_TYPE: 'apt' # yum | apt | zypp | win
#    steps:
#    - uses: actions/checkout@v2
#    - name: Update APT repo
#      run: |
#        cd cicd
#        source scripts/pipeline_functions.sh
#        create_dynamo_table
#        wait_free_lock
#        lock
#        docker-compose --file docker_compose_apt_updater.yml run release
#        release_lock
#
#  s3-yum-update:
#    name: S3 YUM update
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    env:
#      BASE_PATH: "/infrastructure_agent/linux/yum/el"
#      LOCK_REPO_TYPE: 'yum'
#    steps:
#    - uses: actions/checkout@v2
#    - name: Upload & update YUM repo
#      run: |
#        cd cicd
#        source scripts/pipeline_functions.sh # import functions
#        create_dynamo_table
#        wait_free_lock
#        lock
#        docker-compose --file docker_compose_yum_updater.yml run release
#        release_lock
#
#  s3-zypp-update:
#    name: S3 ZYPP update
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    env:
#      BASE_PATH: "/infrastructure_agent/linux/zypp/sles"
#      LOCK_REPO_TYPE: 'zypp'
#    steps:
#    - uses: actions/checkout@v2
#    - name: Upload & update ZYPP repo
#      run: |
#        cd cicd
#        source scripts/pipeline_functions.sh # import functions
#        create_dynamo_table
#        wait_free_lock
#        lock
#        docker-compose --file docker_compose_zypp_updater.yml run release
#        release_lock
#
#  s3-tarball-update:
#    name: S3 Tarball Linux & Windows update
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    env:
#      BASE_PATH: "/infrastructure_agent/binaries"
#      LOCK_REPO_TYPE: 'tarball'
#    steps:
#    - uses: actions/checkout@v2
#    - name: Upload tarballs
#      run: |
#        cd cicd
#        source scripts/pipeline_functions.sh # import functions
#        create_dynamo_table
#        wait_free_lock
#        lock
#        docker-compose --file docker_compose_tarball_updater.yml run release
#        release_lock

#  docker-image-update:
#    name: Docker image creation and push to Registry
#    if: github.event.action == 'released'
#    needs: [goreleaser]
#    runs-on: ubuntu-latest
#    steps:
#    - uses: actions/checkout@v2
#    - name: Create image creation and push
#      run: |
#        cd cicd
#        docker-compose --file docker_compose_docker_image_creator.yml run release
